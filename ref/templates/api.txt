..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: In Progress $
..   $OriginalRevision: 11332 $
..   $TranslationAuthors: None $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _ref-templates-api:

============================================================
A linguagem de template do Django: Para programadores Python
============================================================

Este documento explica o sistema de template do Django a partir de uma 
perspectiva técnica -- como ela funciona e como estendê-la. Se você só está 
procurando por referência sobre a sintaxe da linguagem, veja 
:ref:`topics-templates`.

Se você estiver procurando usar o sistema de template do Django como parte de
outra aplicação -- i.e., sem o resto do framework -- esteja certo de ler a
seção `configuração`_ mais adiante neste documento.

.. _configuração: `configurando o sistema de template do django no modo standalone`_

Fundamentos
===========

Um **template** é um documento de texto, ou uma string do Python normal, que é
marcado usando a linguagem de template do Django. Um template pode conter
**tags de bloco** ou **variáveis**.

Uma **tag de bloco** é um símbolo dentro de um template que faz algo.

Esta definição deliberadamente vaga. Por exemplo, uma tag de bloco pode gerar
conteúdo, serve como um controle de strutura (uma declaração "if" ou laço 
"for"), apanha conteúdo do banco de dados ou habilita acesso para outras tags
de template.

Tags de bloco são envolvidas por ``"{%}"`` e ``"%}"``.

Exemplo de template exemplo com tags de bloco:

.. code-block:: html+django

    {% if is_logged_in %}Thanks for logging in!{% else %}Please log in.{% endif %}

Uma **variável** é um símbolo dentro de um template que gera um valor.

Tags de variáveis são envolvidas por ``"{{"`` e ``"}}"``.

Exemplo de template com variáveis:

.. code-block:: html+django

    My first name is {{ first_name }}. My last name is {{ last_name }}.

A **context** is a "variable name" -> "variable value" mapping that is passed
to a template.

Um template **renderiza** um contexto substituindo a variável "holes" com os 
valores do contexto e executando todas tags de bloco.

Usando o sistema de template
============================

Usar o sistema de templates no Python é um processo de dois passos:

    * Primeiro, você compila o código do template puro dentro de um objeto 
      ``Template``.
    * Depois, você  chama o método ``render()`` do objeto ``Template`` com um
      dado contexto.

Compilando uma string
---------------------

A forma mais fácil de criar um objeto de ``Template`` é instanciando-o 
diretamente. A classe fica em ``django.template.Template``. O construtor recebe 
um argumento -- o código do template puro::

    >>> from django.template import Template
    >>> t = Template("My name is {{ my_name }}.")
    >>> print t
    <django.template.Template instance>

.. admonition:: Por trás das cenas

    O sistema parseia somente o código do template puro -- quando você cria o
    objeto ``Template``. A partir de entnao, é armazenado internamente como um
    "nodo" da estrutura por questões de performance.

    Mesmo o parseamento em si é bem rápido. A maioria do parseamento acontece
    através de uma única chamada para uma única, e curta, expressão regular.

Renderizando um contexto
------------------------

Uma vez que você tenha compilado o objeto ``Template``, você pode renderizar um
contexto -- ou vários contextos -- como ele. A classe ``Context`` fica em
``django.template.Context``, e o seu construtor recebe um argumento (opcional):
um dicionário que mapeia nomes de variáveis para valores de variáveis. E chama o
método ``render()`` dos objetos ``Template`` com o contexto para "preencher" o
template::

    >>> from django.template import Context, Template
    >>> t = Template("My name is {{ my_name }}.")

    >>> c = Context({"my_name": "Adrian"})
    >>> t.render(c)
    "My name is Adrian."

    >>> c = Context({"my_name": "Dolores"})
    >>> t.render(c)
    "My name is Dolores."

Nomes de variáveis devem consistir de uma letra (A-Z), qualquer dígito (0-9), e
um sublinhado ou ponto.

Dots have a special meaning in template rendering. A dot in a variable name
signifies **lookup**. Specifically, when the template system encounters a dot
in a variable name, it tries the following lookups, in this order:
Pontos possuem um significado especial na renderização do template. Um ponto no
nome da variável significa **acesso**. Especificamente, quando o sistema de
template enconra um ponto no nome de uma variável, ele tenta seguir a seguinte
pesquisa, nesta ordem:

    * Acesso a dicionário. Exemplo: ``foo["bar"]``
    * Acesso a atributo. Exemplo: ``foo.bar``
    * Chamada de método. Exemplo: ``foo.bar()``
    * Acesso a indíce de lista. Exemplo: ``foo[bar]``
    

O sistema de template usa o primeiro tipo de acesso que funcionar. É um lógica
de curto-circuito.

Aqui tem alguns exemplos::

    >>> from django.template import Context, Template
    >>> t = Template("My name is {{ person.first_name }}.")
    >>> d = {"person": {"first_name": "Joe", "last_name": "Johnson"}}
    >>> t.render(Context(d))
    "My name is Joe."

    >>> class PersonClass: pass
    >>> p = PersonClass()
    >>> p.first_name = "Ron"
    >>> p.last_name = "Nasty"
    >>> t.render(Context({"person": p}))
    "My name is Ron."

    >>> class PersonClass2:
    ...     def first_name(self):
    ...         return "Samantha"
    >>> p = PersonClass2()
    >>> t.render(Context({"person": p}))
    "My name is Samantha."

    >>> t = Template("The first stooge in the list is {{ stooges.0 }}.")
    >>> c = Context({"stooges": ["Larry", "Curly", "Moe"]})
    >>> t.render(c)
    "The first stooge in the list is Larry."

Acesso a métodos são ligeiramente mais complexos em relação aos outros tipos de
acessos. Há coisas que a se manter em mente:

    * Se durante o acesso ao método, um método lançar uma exceção, a exceção 
      será propagada, a menos que a exceção tenha um atributo 
      ``silent_variable_failure`` cujo valor seja ``True``. Se a exceção *tem*
      um atributo ``silent_variable_failure``, a variável será renderizada como
      uma string vazia. Exemplo::

        >>> t = Template("My name is {{ person.first_name }}.")
        >>> class PersonClass3:
        ...     def first_name(self):
        ...         raise AssertionError, "foo"
        >>> p = PersonClass3()
        >>> t.render(Context({"person": p}))
        Traceback (most recent call last):
        ...
        AssertionError: foo

        >>> class SilentAssertionError(Exception):
        ...     silent_variable_failure = True
        >>> class PersonClass4:
        ...     def first_name(self):
        ...         raise SilentAssertionError
        >>> p = PersonClass4()
        >>> t.render(Context({"person": p}))
        "My name is ."

      Perceba que ``django.core.exceptions.ObjectDoesNotExist``, que é a classe
      base para exceção ``DoesNotExist`` de toda API de banco de dados do 
      Django, possui ``silent_variable_failure = True``. Então se você estiver
      usando templates do Django com objetos de model, qualquer exceção
      ``DoesNotExist`` falhará silenciosamente.

    * Uma chamada de método somente funcionará se o método não tiver argumentos
      obrigatórios. Caso contrário, o sistema se moverá para o próximo tipo de
      acesso (acesso a indíce de lista).

    * Obviamente, alguns métodos tem um efeito colateral, e seria tolo ou 
      representaria uma falha de segurança permitir que o sistema de template
      acesse-os.

      Um bom exemplo é o método ``delete()`` em cada objeto de model do Django
      possui. Ao sistema de template não e permitido fazer algo deste tipo::

        Eu irei agora deletar esse dado valioso. {{ data.delete }}

      Para previnir isso, configure um atributo de função ``alters_data`` no 
      método. O sistema de template não executará um método se o mesmo tem o 
      ``alters_data=True`` configurado. Os métodos dinamicamente gerados
      ``delete()`` e ``save()`` nos objetos de model do Django obtêm 
      ``alters_data=True`` automaticamente. Exemplo::

        def sensitive_function(self):
            self.database_record.delete()
        sensitive_function.alters_data = True

.. _invalid-template-variables:

Como variáveis inválidas são manipuladas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Geralmente, se uma variável não existe, o sistema de template insere o valor da
configuração :setting:`TEMPLATE_STRING_IF_INVALID`, que é configurado como 
``''`` (uma string vazia) por padrão.

Filtros que são aplicado numa variável inválida somente serão aplicados se
:setting:`TEMPLATE_STRING_IF_INVALID` for configurado como ``''`` (uma string
vazia). Se :setting:`TEMPLATE_STRING_IF_INVALID` for configurado com qualquer
outro valor, a variável filtro serão ignorados.

Este comportamento é ligeiramente diferente das tags de template ``if``, ``for``
e ``regroup``. Se uma variável inválida é fornecida para uma dessas tags de
template, a variável será interpretada como ``None``. Os filtros são sempre
aplicados em variáveis inválidas dentro destas tags de template.

Se :setting:`TEMPLATE_STRING_IF_INVALID` contém um ``'%s'``, o formato do 
marcador será substituido com o nome da variável inválida.

.. admonition:: Somente para fins de depuração!

    Enquanto :setting:`TEMPLATE_STRING_IF_INVALID` pode ser uma ferramenta de
    depuração útil, também pode ser uma péssima idéia ligá-la como um 'padrão de
    desenvolvimento'.
    
    Muitos templates, incluíndo os do site Admin, confiam no silêncio do sistema
    de template quando uma variável não existene é encontrada. Se você atribui
    um valor diferente de ``''`` para :setting:`TEMPLATE_STRING_IF_INVALID`, 
    você experimentará problemas de renderização com estes templates e sites.

    Geralmente, :setting:`TEMPLATE_STRING_IF_INVALID` somente pode ser 
    habilitado para fins de depuraçnao num problema específico de um template, 
    uma vez que esteja concluída a depuração ele deve ser limpo.

Brincando com objetos de contexto
---------------------------------

Na maior parte do tempo, você instanciará objetos ``Context`` passando num 
dicionário completamente populado ao ``Context()``. Mas você pode adicionar e 
deletar ítens de um objeto ``Context`` uma vez que o tenha instanciado, também,
usando a sintaxe padrão do dicionário::

    >>> c = Context({"foo": "bar"})
    >>> c['foo']
    'bar'
    >>> del c['foo']
    >>> c['foo']
    ''
    >>> c['newvariable'] = 'hello'
    >>> c['newvariable']
    'hello'

Um objeto ``Context`` é uma pilha. Isto é, você pode executar ``push()`` e 
``pop()``. Se você executar o ``pop()`` insistentemente, ele lançará um
``django.template.ContextPopException``::

    >>> c = Context()
    >>> c['foo'] = 'first level'
    >>> c.push()
    >>> c['foo'] = 'second level'
    >>> c['foo']
    'second level'
    >>> c.pop()
    >>> c['foo']
    'first level'
    >>> c['foo'] = 'overwritten'
    >>> c['foo']
    'overwritten'
    >>> c.pop()
    Traceback (most recent call last):
    ...
    django.template.ContextPopException

Usando um ``Context`` como uma pilha vem a calhar em algumas tags de template,
como você verá abaixo.

.. _subclassing-context-requestcontext:

Estendendo Context: RequestContext
----------------------------------

O Django vem com uma classe ``Context`` especial
``django.template.RequestContext``, que age ligeiramente diferente da classe
normal ``django.template.Context``. A primeira difereça é que ele recebe um
:class:`~django.http.HttpRequest` como o seu primeiro argumento. Por exemplo::

    c = RequestContext(request, {
        'foo': 'bar',
    })

A segunda diferença é que ele automaticamente popula o contexto com umas poucas
variáveis, de acordo com a sua configuração 
:setting:`TEMPLATE_CONTEXT_PROCESSORS`.

A configuração :setting:`TEMPLATE_CONTEXT_PROCESSORS` é uma tupla de 
chamáveis -- chamado **processador de contexto** -- que recebe um objeto de
requisição como seu argumento e retorna um dicionário para ser mesclado dentro
do contexto. Por padrão, :setting:`TEMPLATE_CONTEXT_PROCESSORS` é configurado
como::

    ("django.core.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media")

Cada processador é aplicado na ordem. Isso significa que um processador que
adiciona uma variável ao contexto e um segundo processador adiciona uma variável
com o mesmo nome, a segunda sobrescreverá o primeiro. O processador padrão será
explicado abaixo.

Also, you can give ``RequestContext`` a list of additional processors, using the
optional, third positional argument, ``processors``. In this example, the
``RequestContext`` instance gets a ``ip_address`` variable::

    def ip_address_processor(request):
        return {'ip_address': request.META['REMOTE_ADDR']}

    def some_view(request):
        # ...
        c = RequestContext(request, {
            'foo': 'bar',
        }, [ip_address_processor])
        return HttpResponse(t.render(c))

.. note::
    If you're using Django's ``render_to_response()`` shortcut to populate a
    template with the contents of a dictionary, your template will be passed a
    ``Context`` instance by default (not a ``RequestContext``). To use a
    ``RequestContext`` in your template rendering, pass an optional third
    argument to ``render_to_response()``: a ``RequestContext``
    instance. Your code might look like this::

        def some_view(request):
            # ...
            return render_to_response('my_template.html',
                                      my_data_dictionary,
                                      context_instance=RequestContext(request))

Here's what each of the default processors does:

django.core.context_processors.auth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every
``RequestContext`` will contain these three variables:

    * ``user`` -- An ``auth.User`` instance representing the currently
      logged-in user (or an ``AnonymousUser`` instance, if the client isn't
      logged in).

    * ``messages`` -- A list of messages (as strings) for the currently
      logged-in user. Behind the scenes, this calls
      ``request.user.get_and_delete_messages()`` for every request. That method
      collects the user's messages and deletes them from the database.

      Note that messages are set with ``user.message_set.create``.

    * ``perms`` -- An instance of
      ``django.core.context_processors.PermWrapper``, representing the
      permissions that the currently logged-in user has.

django.core.context_processors.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every
``RequestContext`` will contain these two variables -- but only if your
:setting:`DEBUG` setting is set to ``True`` and the request's IP address
(``request.META['REMOTE_ADDR']``) is in the :setting:`INTERNAL_IPS` setting:

    * ``debug`` -- ``True``. You can use this in templates to test whether
      you're in :setting:`DEBUG` mode.
    * ``sql_queries`` -- A list of ``{'sql': ..., 'time': ...}`` dictionaries,
      representing every SQL query that has happened so far during the request
      and how long it took. The list is in order by query.

django.core.context_processors.i18n
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every
``RequestContext`` will contain these two variables:

    * ``LANGUAGES`` -- The value of the :setting:`LANGUAGES` setting.
    * ``LANGUAGE_CODE`` -- ``request.LANGUAGE_CODE``, if it exists. Otherwise,
      the value of the :setting:`LANGUAGE_CODE` setting.

See :ref:`topics-i18n` for more.

django.core.context_processors.media
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every
``RequestContext`` will contain a variable ``MEDIA_URL``, providing the
value of the :setting:`MEDIA_URL` setting.

django.core.context_processors.request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If :setting:`TEMPLATE_CONTEXT_PROCESSORS` contains this processor, every
``RequestContext`` will contain a variable ``request``, which is the current
:class:`~django.http.HttpRequest`. Note that this processor is not enabled by default;
you'll have to activate it.

Writing your own context processors
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

A context processor has a very simple interface: It's just a Python function
that takes one argument, an ``HttpRequest`` object, and returns a dictionary
that gets added to the template context. Each context processor *must* return
a dictionary.

Custom context processors can live anywhere in your code base. All Django cares
about is that your custom context processors are pointed-to by your
:setting:`TEMPLATE_CONTEXT_PROCESSORS` setting.

Loading templates
-----------------

Generally, you'll store templates in files on your filesystem rather than using
the low-level ``Template`` API yourself. Save templates in a directory
specified as a **template directory**.

Django searches for template directories in a number of places, depending on
your template-loader settings (see "Loader types" below), but the most basic
way of specifying template directories is by using the :setting:`TEMPLATE_DIRS`
setting.

The TEMPLATE_DIRS setting
~~~~~~~~~~~~~~~~~~~~~~~~~

Tell Django what your template directories are by using the
:setting:`TEMPLATE_DIRS` setting in your settings file. This should be set to a
list or tuple of strings that contain full paths to your template
directory(ies). Example::

    TEMPLATE_DIRS = (
        "/home/html/templates/lawrence.com",
        "/home/html/templates/default",
    )

Your templates can go anywhere you want, as long as the directories and
templates are readable by the Web server. They can have any extension you want,
such as ``.html`` or ``.txt``, or they can have no extension at all.

Note that these paths should use Unix-style forward slashes, even on Windows.

.. _ref-templates-api-the-python-api:

The Python API
~~~~~~~~~~~~~~

Django has two ways to load templates from files:

``django.template.loader.get_template(template_name)``
    ``get_template`` returns the compiled template (a ``Template`` object) for
    the template with the given name. If the template doesn't exist, it raises
    ``django.template.TemplateDoesNotExist``.

``django.template.loader.select_template(template_name_list)``
    ``select_template`` is just like ``get_template``, except it takes a list
    of template names. Of the list, it returns the first template that exists.

For example, if you call ``get_template('story_detail.html')`` and have the
above :setting:`TEMPLATE_DIRS` setting, here are the files Django will look for,
in order:

    * ``/home/html/templates/lawrence.com/story_detail.html``
    * ``/home/html/templates/default/story_detail.html``

If you call ``select_template(['story_253_detail.html', 'story_detail.html'])``,
here's what Django will look for:

    * ``/home/html/templates/lawrence.com/story_253_detail.html``
    * ``/home/html/templates/default/story_253_detail.html``
    * ``/home/html/templates/lawrence.com/story_detail.html``
    * ``/home/html/templates/default/story_detail.html``

When Django finds a template that exists, it stops looking.

.. admonition:: Tip

    You can use ``select_template()`` for super-flexible "templatability." For
    example, if you've written a news story and want some stories to have
    custom templates, use something like
    ``select_template(['story_%s_detail.html' % story.id, 'story_detail.html'])``.
    That'll allow you to use a custom template for an individual story, with a
    fallback template for stories that don't have custom templates.

Using subdirectories
~~~~~~~~~~~~~~~~~~~~

It's possible -- and preferable -- to organize templates in subdirectories of
the template directory. The convention is to make a subdirectory for each
Django app, with subdirectories within those subdirectories as needed.

Do this for your own sanity. Storing all templates in the root level of a
single directory gets messy.

To load a template that's within a subdirectory, just use a slash, like so::

    get_template('news/story_detail.html')

Using the same :setting:`TEMPLATE_DIRS` setting from above, this example
``get_template()`` call will attempt to load the following templates:

    * ``/home/html/templates/lawrence.com/news/story_detail.html``
    * ``/home/html/templates/default/news/story_detail.html``

.. _template-loaders:

Loader types
~~~~~~~~~~~~

By default, Django uses a filesystem-based template loader, but Django comes
with a few other template loaders, which know how to load templates from other
sources.

Some of these other loaders are disabled by default, but you can activate them
by editing your :setting:`TEMPLATE_LOADERS` setting. :setting:`TEMPLATE_LOADERS`
should be a tuple of strings, where each string represents a template loader.
Here are the template loaders that come with Django:

``django.template.loaders.filesystem.load_template_source``
    Loads templates from the filesystem, according to :setting:`TEMPLATE_DIRS`.
    This loader is enabled by default.

``django.template.loaders.app_directories.load_template_source``
    Loads templates from Django apps on the filesystem. For each app in
    :setting:`INSTALLED_APPS`, the loader looks for a ``templates``
    subdirectory. If the directory exists, Django looks for templates in there.

    This means you can store templates with your individual apps. This also
    makes it easy to distribute Django apps with default templates.

    For example, for this setting::

        INSTALLED_APPS = ('myproject.polls', 'myproject.music')

    ...then ``get_template('foo.html')`` will look for templates in these
    directories, in this order:

        * ``/path/to/myproject/polls/templates/foo.html``
        * ``/path/to/myproject/music/templates/foo.html``

    Note that the loader performs an optimization when it is first imported: It
    caches a list of which :setting:`INSTALLED_APPS` packages have a
    ``templates`` subdirectory.
    
    This loader is enabled by default.

``django.template.loaders.eggs.load_template_source``
    Just like ``app_directories`` above, but it loads templates from Python
    eggs rather than from the filesystem.
    
    This loader is disabled by default.

Django uses the template loaders in order according to the
:setting:`TEMPLATE_LOADERS` setting. It uses each loader until a loader finds a
match.

The ``render_to_string()`` shortcut
===================================

To cut down on the repetitive nature of loading and rendering
templates, Django provides a shortcut function which largely
automates the process: ``render_to_string()`` in
``django.template.loader``, which loads a template, renders it and
returns the resulting string::

    from django.template.loader import render_to_string
    rendered = render_to_string('my_template.html', { 'foo': 'bar' })

The ``render_to_string`` shortcut takes one required argument --
``template_name``, which should be the name of the template to load
and render -- and two optional arguments:

    dictionary
        A dictionary to be used as variables and values for the
        template's context. This can also be passed as the second
        positional argument.

    context_instance
        An instance of ``Context`` or a subclass (e.g., an instance of
        ``RequestContext``) to use as the template's context. This can
        also be passed as the third positional argument.

See also the :func:`~django.shortcuts.render_to_response()` shortcut, which
calls ``render_to_string`` and feeds the result into an ``HttpResponse``
suitable for returning directly from a view.

Configuring the template system in standalone mode
==================================================

.. note::

    This section is only of interest to people trying to use the template
    system as an output component in another application. If you're using the
    template system as part of a Django application, nothing here applies to
    you.

Normally, Django will load all the configuration information it needs from its
own default configuration file, combined with the settings in the module given
in the :setting:`DJANGO_SETTINGS_MODULE` environment variable. But if you're
using the template system independently of the rest of Django, the environment
variable approach isn't very convenient, because you probably want to configure
the template system in line with the rest of your application rather than
dealing with settings files and pointing to them via environment variables.

To solve this problem, you need to use the manual configuration option described
in :ref:`settings-without-django-settings-module`. Simply import the appropriate
pieces of the templating system and then, *before* you call any of the
templating functions, call ``django.conf.settings.configure()`` with any
settings you wish to specify. You might want to consider setting at least
:setting:`TEMPLATE_DIRS` (if you're going to use template loaders),
:setting:`DEFAULT_CHARSET` (although the default of ``utf-8`` is probably fine)
and :setting:`TEMPLATE_DEBUG`. All available settings are described in the
:ref:`settings documentation <ref-settings>`, and any setting starting with
``TEMPLATE_`` is of obvious interest.
