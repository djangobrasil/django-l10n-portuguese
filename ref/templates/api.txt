..
.. META INFORMATION OF TRANSLATION
..
..   $TranslationStatus: Done, waiting for revision $
..   $OriginalRevision: 11332 $
..   $TranslationAuthors: Robson Mendonça $
..
.. INFO OF THIS FILE (DO NOT EDIT! UPDATED BY SUBVERSION)
..
..   $HeadURL$
..   $LastChangedRevision$
..   $LastChangedBy$
..   $LastChangedDate$
..


.. _ref-templates-api:

============================================================
A linguagem de template do Django: Para programadores Python
============================================================

Este documento explica o sistema de template do Django a partir de uma 
perspectiva técnica -- como ela funciona e como estendê-la. Se você só está 
procurando por referência sobre a sintaxe da linguagem, veja 
:ref:`topics-templates`.

Se você estiver procurando usar o sistema de template do Django como parte de
outra aplicação -- i.e., sem o resto do framework -- esteja certo de ler a
seção `configuração`_ mais adiante neste documento.

.. _configuração: `configurando o sistema de template do django no modo standalone`_

Fundamentos
===========

Um **template** é um documento de texto, ou uma string do Python normal, que é
marcado usando a linguagem de template do Django. Um template pode conter
**tags de bloco** ou **variáveis**.

Uma **tag de bloco** é um símbolo dentro de um template que faz algo.

Esta definição deliberadamente vaga. Por exemplo, uma tag de bloco pode gerar
conteúdo, serve como um controle de strutura (uma declaração "if" ou laço 
"for"), apanha conteúdo do banco de dados ou habilita acesso para outras tags
de template.

Tags de bloco são envolvidas por ``"{%}"`` e ``"%}"``.

Exemplo de template exemplo com tags de bloco:

.. code-block:: html+django

    {% if is_logged_in %}Thanks for logging in!{% else %}Please log in.{% endif %}

Uma **variável** é um símbolo dentro de um template que gera um valor.

Tags de variáveis são envolvidas por ``"{{"`` e ``"}}"``.

Exemplo de template com variáveis:

.. code-block:: html+django

    My first name is {{ first_name }}. My last name is {{ last_name }}.

A **context** is a "variable name" -> "variable value" mapping that is passed
to a template.

Um template **renderiza** um contexto substituindo a variável "holes" com os 
valores do contexto e executando todas tags de bloco.

Usando o sistema de template
============================

Usar o sistema de templates no Python é um processo de dois passos:

    * Primeiro, você compila o código do template puro dentro de um objeto 
      ``Template``.
    * Depois, você  chama o método ``render()`` do objeto ``Template`` com um
      dado contexto.

Compilando uma string
---------------------

A forma mais fácil de criar um objeto de ``Template`` é instanciando-o 
diretamente. A classe fica em ``django.template.Template``. O construtor recebe 
um argumento -- o código do template puro::

    >>> from django.template import Template
    >>> t = Template("My name is {{ my_name }}.")
    >>> print t
    <django.template.Template instance>

.. admonition:: Por trás das cenas

    O sistema parseia somente o código do template puro -- quando você cria o
    objeto ``Template``. A partir de entnao, é armazenado internamente como um
    "nodo" da estrutura por questões de performance.

    Mesmo o parseamento em si é bem rápido. A maioria do parseamento acontece
    através de uma única chamada para uma única, e curta, expressão regular.

Renderizando um contexto
------------------------

Uma vez que você tenha compilado o objeto ``Template``, você pode renderizar um
contexto -- ou vários contextos -- como ele. A classe ``Context`` fica em
``django.template.Context``, e o seu construtor recebe um argumento (opcional):
um dicionário que mapeia nomes de variáveis para valores de variáveis. E chama o
método ``render()`` dos objetos ``Template`` com o contexto para "preencher" o
template::

    >>> from django.template import Context, Template
    >>> t = Template("My name is {{ my_name }}.")

    >>> c = Context({"my_name": "Adrian"})
    >>> t.render(c)
    "My name is Adrian."

    >>> c = Context({"my_name": "Dolores"})
    >>> t.render(c)
    "My name is Dolores."

Nomes de variáveis devem consistir de uma letra (A-Z), qualquer dígito (0-9), e
um sublinhado ou ponto.

Dots have a special meaning in template rendering. A dot in a variable name
signifies **lookup**. Specifically, when the template system encounters a dot
in a variable name, it tries the following lookups, in this order:
Pontos possuem um significado especial na renderização do template. Um ponto no
nome da variável significa **acesso**. Especificamente, quando o sistema de
template enconra um ponto no nome de uma variável, ele tenta seguir a seguinte
pesquisa, nesta ordem:

    * Acesso a dicionário. Exemplo: ``foo["bar"]``
    * Acesso a atributo. Exemplo: ``foo.bar``
    * Chamada de método. Exemplo: ``foo.bar()``
    * Acesso a indíce de lista. Exemplo: ``foo[bar]``
    

O sistema de template usa o primeiro tipo de acesso que funcionar. É um lógica
de curto-circuito.

Aqui tem alguns exemplos::

    >>> from django.template import Context, Template
    >>> t = Template("My name is {{ person.first_name }}.")
    >>> d = {"person": {"first_name": "Joe", "last_name": "Johnson"}}
    >>> t.render(Context(d))
    "My name is Joe."

    >>> class PersonClass: pass
    >>> p = PersonClass()
    >>> p.first_name = "Ron"
    >>> p.last_name = "Nasty"
    >>> t.render(Context({"person": p}))
    "My name is Ron."

    >>> class PersonClass2:
    ...     def first_name(self):
    ...         return "Samantha"
    >>> p = PersonClass2()
    >>> t.render(Context({"person": p}))
    "My name is Samantha."

    >>> t = Template("The first stooge in the list is {{ stooges.0 }}.")
    >>> c = Context({"stooges": ["Larry", "Curly", "Moe"]})
    >>> t.render(c)
    "The first stooge in the list is Larry."

Acesso a métodos são ligeiramente mais complexos em relação aos outros tipos de
acessos. Há coisas que a se manter em mente:

    * Se durante o acesso ao método, um método lançar uma exceção, a exceção 
      será propagada, a menos que a exceção tenha um atributo 
      ``silent_variable_failure`` cujo valor seja ``True``. Se a exceção *tem*
      um atributo ``silent_variable_failure``, a variável será renderizada como
      uma string vazia. Exemplo::

        >>> t = Template("My name is {{ person.first_name }}.")
        >>> class PersonClass3:
        ...     def first_name(self):
        ...         raise AssertionError, "foo"
        >>> p = PersonClass3()
        >>> t.render(Context({"person": p}))
        Traceback (most recent call last):
        ...
        AssertionError: foo

        >>> class SilentAssertionError(Exception):
        ...     silent_variable_failure = True
        >>> class PersonClass4:
        ...     def first_name(self):
        ...         raise SilentAssertionError
        >>> p = PersonClass4()
        >>> t.render(Context({"person": p}))
        "My name is ."

      Perceba que ``django.core.exceptions.ObjectDoesNotExist``, que é a classe
      base para exceção ``DoesNotExist`` de toda API de banco de dados do 
      Django, possui ``silent_variable_failure = True``. Então se você estiver
      usando templates do Django com objetos de model, qualquer exceção
      ``DoesNotExist`` falhará silenciosamente.

    * Uma chamada de método somente funcionará se o método não tiver argumentos
      obrigatórios. Caso contrário, o sistema se moverá para o próximo tipo de
      acesso (acesso a indíce de lista).

    * Obviamente, alguns métodos tem um efeito colateral, e seria tolo ou 
      representaria uma falha de segurança permitir que o sistema de template
      acesse-os.

      Um bom exemplo é o método ``delete()`` em cada objeto de model do Django
      possui. Ao sistema de template não e permitido fazer algo deste tipo::

        Eu irei agora deletar esse dado valioso. {{ data.delete }}

      Para previnir isso, configure um atributo de função ``alters_data`` no 
      método. O sistema de template não executará um método se o mesmo tem o 
      ``alters_data=True`` configurado. Os métodos dinamicamente gerados
      ``delete()`` e ``save()`` nos objetos de model do Django obtêm 
      ``alters_data=True`` automaticamente. Exemplo::

        def sensitive_function(self):
            self.database_record.delete()
        sensitive_function.alters_data = True

.. _invalid-template-variables:

Como variáveis inválidas são manipuladas
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Geralmente, se uma variável não existe, o sistema de template insere o valor da
configuração :setting:`TEMPLATE_STRING_IF_INVALID`, que é configurado como 
``''`` (uma string vazia) por padrão.

Filtros que são aplicado numa variável inválida somente serão aplicados se
:setting:`TEMPLATE_STRING_IF_INVALID` for configurado como ``''`` (uma string
vazia). Se :setting:`TEMPLATE_STRING_IF_INVALID` for configurado com qualquer
outro valor, a variável filtro serão ignorados.

Este comportamento é ligeiramente diferente das tags de template ``if``, ``for``
e ``regroup``. Se uma variável inválida é fornecida para uma dessas tags de
template, a variável será interpretada como ``None``. Os filtros são sempre
aplicados em variáveis inválidas dentro destas tags de template.

Se :setting:`TEMPLATE_STRING_IF_INVALID` contém um ``'%s'``, o formato do 
marcador será substituido com o nome da variável inválida.

.. admonition:: Somente para fins de depuração!

    Enquanto :setting:`TEMPLATE_STRING_IF_INVALID` pode ser uma ferramenta de
    depuração útil, também pode ser uma péssima idéia ligá-la como um 'padrão de
    desenvolvimento'.
    
    Muitos templates, incluíndo os do site Admin, confiam no silêncio do sistema
    de template quando uma variável não existene é encontrada. Se você atribui
    um valor diferente de ``''`` para :setting:`TEMPLATE_STRING_IF_INVALID`, 
    você experimentará problemas de renderização com estes templates e sites.

    Geralmente, :setting:`TEMPLATE_STRING_IF_INVALID` somente pode ser 
    habilitado para fins de depuraçnao num problema específico de um template, 
    uma vez que esteja concluída a depuração ele deve ser limpo.

Brincando com objetos de contexto
---------------------------------

Na maior parte do tempo, você instanciará objetos ``Context`` passando num 
dicionário completamente populado ao ``Context()``. Mas você pode adicionar e 
deletar ítens de um objeto ``Context`` uma vez que o tenha instanciado, também,
usando a sintaxe padrão do dicionário::

    >>> c = Context({"foo": "bar"})
    >>> c['foo']
    'bar'
    >>> del c['foo']
    >>> c['foo']
    ''
    >>> c['newvariable'] = 'hello'
    >>> c['newvariable']
    'hello'

Um objeto ``Context`` é uma pilha. Isto é, você pode executar ``push()`` e 
``pop()``. Se você executar o ``pop()`` insistentemente, ele lançará um
``django.template.ContextPopException``::

    >>> c = Context()
    >>> c['foo'] = 'first level'
    >>> c.push()
    >>> c['foo'] = 'second level'
    >>> c['foo']
    'second level'
    >>> c.pop()
    >>> c['foo']
    'first level'
    >>> c['foo'] = 'overwritten'
    >>> c['foo']
    'overwritten'
    >>> c.pop()
    Traceback (most recent call last):
    ...
    django.template.ContextPopException

Usando um ``Context`` como uma pilha vem a calhar em algumas tags de template,
como você verá abaixo.

.. _subclassing-context-requestcontext:

Estendendo Context: RequestContext
----------------------------------

O Django vem com uma classe ``Context`` especial
``django.template.RequestContext``, que age ligeiramente diferente da classe
normal ``django.template.Context``. A primeira difereça é que ele recebe um
:class:`~django.http.HttpRequest` como o seu primeiro argumento. Por exemplo::

    c = RequestContext(request, {
        'foo': 'bar',
    })

A segunda diferença é que ele automaticamente popula o contexto com umas poucas
variáveis, de acordo com a sua configuração 
:setting:`TEMPLATE_CONTEXT_PROCESSORS`.

A configuração :setting:`TEMPLATE_CONTEXT_PROCESSORS` é uma tupla de 
chamáveis -- chamado **processador de contexto** -- que recebe um objeto de
requisição como seu argumento e retorna um dicionário para ser mesclado dentro
do contexto. Por padrão, :setting:`TEMPLATE_CONTEXT_PROCESSORS` é configurado
como::

    ("django.core.context_processors.auth",
    "django.core.context_processors.debug",
    "django.core.context_processors.i18n",
    "django.core.context_processors.media")

Cada processador é aplicado na ordem. Isso significa que um processador que
adiciona uma variável ao contexto e um segundo processador adiciona uma variável
com o mesmo nome, a segunda sobrescreverá o primeiro. O processador padrão será
explicado abaixo.

Também, você pode fornecer ao ``RequestContext`` uma lista de processadores
adicionais, usando o terceiro argumento (opcional), ``processors``. Neste 
exemplo, a instância ``RequestContext`` recebe uma variável ``ip_address``::

    def ip_address_processor(request):
        return {'ip_address': request.META['REMOTE_ADDR']}

    def some_view(request):
        # ...
        c = RequestContext(request, {
            'foo': 'bar',
        }, [ip_address_processor])
        return HttpResponse(t.render(c))

.. note::
    Se você estiver usando o atalho ``render_to_response()`` do Django para
    popular um template com os conteúdos de um dicionário, ao seu template será
    passado uma instância de ``Context`` por padrão (não um ``RequestContext``).
    Para usar um ``RequestContext`` na renderização do seu template, passe o 
    terceiro parâmetro opcional para o ``render_to_response()``: uma instância
    do ``RequestContext``. Seu código pode parecer com isso::

        def some_view(request):
            # ...
            return render_to_response('my_template.html',
                                      my_data_dictionary,
                                      context_instance=RequestContext(request))

Aqui temos o que cada processador padrão faz:

django.core.context_processors.auth
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se :setting:`TEMPLATE_CONTEXT_PROCESSORS` conter seu processador, todo
``RequestContext`` conterá estas três variáveis:

    * ``user`` -- uma instância de ``auth.User`` representano o usuário 
      atualmente logado (ou uma instância de ``AnonymousUser``, se o cliente não
      estiver logado).

    * ``messages`` -- Uma lista de mensagens (strings) para o usuário atualmente
      logado. Por trás das cenas, este chama
      ``request.user.get_and_delete_messages()`` para cada requisição. Este 
      método coleta as mensagens do usuário e as remove do banco de dados.

      Note que as mensagens são configurada com ``user.message_set.create``.

    * ``perms`` -- Uma instância do 
      ``django.core.context_processors.PermWrapper``, representando as 
      permissões que o usuário atualmente logado possui.

django.core.context_processors.debug
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se :setting:`TEMPLATE_CONTEXT_PROCESSORS` contém este processador, cada
``RequestContext`` conterá estas duas variáveis -- mas somente se sua 
configuração :setting:`DEBUG` configurada como ``True`` e o endereço IP da
requisição (``request.META['REMOTE_ADDR']``) estiver na configuração 
:setting:`INTERNAL_IPS`:

    * ``debug`` -- ``True``. Você pode usar isso dentro do template para testar
      se você está no modo :setting:`DEBUG`.
    * ``sql_queries`` -- Uma lista de dicionários ``{'sql': ..., 'time': ...}``,
      representando cada consulta SQL que aconteceu durante a requisição e em
      quanto tempo ela foi executada. A lista está na ordem de consulta.

django.core.context_processors.i18n
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se :setting:`TEMPLATE_CONTEXT_PROCESSORS` contém este processador, todo
``RequestContext`` conterá estas duas variáveis:

    * ``LANGUAGES`` -- O valor da configuração :setting:`LANGUAGES`.
    * ``LANGUAGE_CODE`` -- ``request.LANGUAGE_CODE``, se ele existe. Do 
      contrário, o valor é o da configuração :setting:`LANGUAGE_CODE`.

Veja :ref:`topics-i18n` para mais.

django.core.context_processors.media
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

.. versionadded:: 1.0

Se :setting:`TEMPLATE_CONTEXT_PROCESSORS` contém este processador, cada
``RequestContext`` conterá uma variável ``MEDIA_URL``, fornecendo o valor da
configuração :setting:`MEDIA_URL`.

django.core.context_processors.request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Se :setting:`TEMPLATE_CONTEXT_PROCESSORS` contém este processador, cada
``RequestContext`` conterá uma variável ``request``, que é o atual
:class:`~django.http.HttpRequest`. Note que este processaodr não está habilitado
por padrão; você precisa ativá-lo.

Escrevendo seu próprio processador de contexto
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Um processador de contexto tem uma interface muito simples: É somente uma função
Python que recebe um argumento, um objeto ``HttpRequest``, e retorna um 
dicionário que será adicionado ao contexto do template´. Cada processador de 
contexto *deve* retornar um dicionário.

Processadores de contexto podem ficar em qualquer parte de sua base de código.
Tudo com o que o Django se preocupa é que seu processador de contexto seja
apontado pela a sua configuração :setting:`TEMPLATE_CONTEXT_PROCESSORS`.

Carregando templates
--------------------

Geralmente, você armazenará templates em arquivos no seu sistema de arquivos ao
invés de usar a API de ``Template`` de baixo nível em si. Guarde os templates 
num diretório especificado com um **diretório de template**.

O Django procura por diretórios de templates em alguns lugares, dependendo da
sua configuração do carregador de template (veja "Tipos de carregadores" 
abaixo), mas a forma mais básica de especificar diretórios de templates é usando
a configuração :setting:`TEMPLATE_DIRS`.

A configuração TEMPLATE_DIRS
~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Diz ao Django aonde seus diretórios de templates estão usando a configuração
:setting:`TEMPLATE_DIRS` no seu arquivo de configuração. Este deve ser 
configurado como uma lista ou tupla de strings que contenham caminhos completos
dos seus templates. Exemplo::

    TEMPLATE_DIRS = (
        "/home/html/templates/lawrence.com",
        "/home/html/templates/default",
    )

Seus template podem fica em qualquer lugar, desde que seus diretórios de 
templates possam ser lidos pelo servidor Web. Eles podem ter qualquer extensão
que você quiser, tais como ``.html`` ou ``.txt``, ou eles podem nem mesmo ter
qualquer extensão.

Perceba que estes caminhos devem ser no estilo Unix com barras, mesmo no 
Windows.

.. _ref-templates-api-the-python-api:

A API do Python
~~~~~~~~~~~~~~~

O Django tem duas formas de carregar templates dos arquivos:

``django.template.loader.get_template(template_name)``
    ``get_template`` retorna o template compilado (um objeto ``Template``) para
    o template com o dado nome. se o template não existir, ele lançará um
    ``django.template.TemplateDoesNotExist``.

``django.template.loader.select_template(template_name_list)``
    ``select_template`` assim como ``get_template``, exceto por receber uma 
    lista de nomes de template. Com base na lista, ele retorna o primeiro 
    template que existir.

Por exemplo, se você chama ``get_template('story_detail.html')`` e tem a 
configuração acima, o Django procurará por estes arquivo, nesta ordem:

    * ``/home/html/templates/lawrence.com/story_detail.html``
    * ``/home/html/templates/default/story_detail.html``

Se você chamar 
``select_template(['story_253_detail.html', 'story_detail.html'])``, aqui tá 
pelo que o Django irá procurar:

    * ``/home/html/templates/lawrence.com/story_253_detail.html``
    * ``/home/html/templates/default/story_253_detail.html``
    * ``/home/html/templates/lawrence.com/story_detail.html``
    * ``/home/html/templates/default/story_detail.html``

Quando o Django encontra um template que existe, ele para de procurar.

.. admonition:: Dica

    Você pode usar ``select_template()`` para tornar os templates super 
    flexíveis. Por exemplo, se você estiver escrevendo um sistema de notícias e
    quiser que algumas tenham um template personalizado, use algo desse tipo
    ``select_template(['story_%s_detail.html' % story.id, 'story_detail.html'])``.
    Isso vai permitir que você use um modelo personalizado para uma notícia
    individual, com um template de reserva para notícias que não tenham
    templates personalizados.

Usando sub-diretórios
~~~~~~~~~~~~~~~~~~~~~

É possível -- e preferível -- organizar os templates em sub diretórios dentro
do diretório de template. A convenção é fazar um sub diretório para cada 
aplicação Django, com sub diretórios dentro deles se necessário.

Faça isso para sua própria sanidade. Armaezenar todos os templates no mesmo 
nível de diretório vira uma bagunça.

Para carregar um template que esteja dentro de um sub diretório, é só usar uma
barra, desta forma::

    get_template('news/story_detail.html')

Usando a mesma configuração acima :setting:`TEMPLATE_DIRS`, este exemplo de
chamada para ``get_template()`` tentará carregar os seguintes templates:

    * ``/home/html/templates/lawrence.com/news/story_detail.html``
    * ``/home/html/templates/default/news/story_detail.html``

.. _template-loaders:

Tipos de carregadores
~~~~~~~~~~~~~~~~~~~~~

Por padrão, o Django usa um carregador de template baseado no sistema de 
arquivos, mas o Django vem com alguns outros tipos de carregador de templates,
que sabem como carregar templates de outras fontes.

Alguns desses outros carregadores são desabilitador por padrão, mas você pode
ativá-los editando sua configuração :setting:`TEMPLATE_LOADERS`. 
:setting:`TEMPLATE_LOADERS` devem ser uma tupla de strings, onde cada string 
representa um carregador de template. Aqui temos os carregadors de template que
acompanham o Django:

``django.template.loaders.filesystem.load_template_source``
    Carrega os templates do sistema de arquivos, de acordo com o 
    :setting:`TEMPLATE_DIRS`. Este carregador está habilitado por padrão.

``django.template.loaders.app_directories.load_template_source``
    Carrega os template das aplicações Django no sistema de arquivos. Para cada
    applicação no :setting:`INSTALLED_APPS`, o carregador procura pelo diretório
    ``tempaltes``. Se o diretório existe, o Django procura pelos templates lá
    dentro.

    Isso significa que você pode armazenar templates dentro de suas aplicações
    individualmente. Isso também torna fácil distribuir suas aplicações Django
    com templates padrão.

    Por exemplo, para esta configuração::

        INSTALLED_APPS = ('myproject.polls', 'myproject.music')

    ...então ``get_template('foo.html')`` procurará pelos templates nestes 
    diretórios, nesta ordem:

        * ``/path/to/myproject/polls/templates/foo.html``
        * ``/path/to/myproject/music/templates/foo.html``

    Percebe-se que o carregador realiza uma otimização quando é importada pela 
    primeira vez: Ele cachea a lista de pacotes :setting:`INSTALLED_APPS` que
    possuem um sub diretório ``templates``.
    
    Este carregador é habilitado por padrão.

``django.template.loaders.eggs.load_template_source``
    Igual ao ``app_directories`` acima, mas ele procura por templates no Python
    eggs ao invés do sistema de arquivos.
    
    Esse carregador é desabilitado por padrão.

O Django usa os carregadores de templates na ordem de acordo com a configuração
:setting:`TEMPLATE_LOADERS`. Ele usa cada carregador até que o carregador 
encontre uma combinação.

O atalho ``render_to_string()``
===============================

Para reduzir a repetição naturla de carregar e renderizar templates, o Django
fornece uma função de atalho que automatiza amplamente o processo: 
``render_to_string()`` no ``django.template.loader``, que carrega um template,
o renderiza e retorna a string resultante::

    from django.template.loader import render_to_string
    rendered = render_to_string('my_template.html', { 'foo': 'bar' })

O atalho ``render_to_string`` recebe um argumento obrigatório -- 
``template_name``, que deve ser o nome do template a ser carregado e 
renderizado -- e dois argumentos opcionais:

    dictionary
        Um dicionário que será usado como variáveis e valores para o contexto do
        template. Este pode ser também passado como o segundo argumento 
        posicional.

    context_instance
        Uma instância de ``Context`` ou uma subclasse (e.g., uma instância de
        ``RequestContext``) para usar como o contexto do template. Este pode ser
        também passado como um terceiro argumento posicional.

Veja também o atalho :func:`~django.shortcuts.render_to_response()`, que chama
``render_to_string`` e alimenta o resultado dentro de um ``HttpResponse`` 
adequado para retornar diretamente a uma view.

Configurando o sistema de template no modo standalone
=====================================================

.. note::

    Esta seção somente é interessante para pessoas que estejam tentando usar o 
    sistema de template como um componente de saída em outra aplicação. Se você
    estiver usando o sitema de template como parte de uma aplicação do Django,
    nada aqui se aplica a você.

Normalmente, o Django carregará todas as informações de configurações que ele 
precisa para seu próprio arquivo de configuração padrão, combinado com as 
configurações no módulo fornecido na variável de ambiente 
:setting:`DJANGO_SETTINGS_MODULE`. Mas se você estiver usando o sistema de 
template independentemente do resto do Django, a abordagem de variável de 
ambiente não é muito conveniente, pois você provavelmente deseja configurar o
sistema de template alinhado com o resto de sua aplicação ao invês de lidar com
arquivos de configuração e apontá-los via variáveis de ambiente.

Para resolver este problema, você precisa usar a opção de  configuração manual 
descrita em :ref:`settings-whitout-django-settings-module`. Simplesmente 
importando as partes apropriadas do sistema de template e então, *antes* de você
chamar qualquer função de templates, chame ``django.conf.settings.configure()``
com qualquer configuração que você deseja especificar. Você pode querer 
considerar configurar pelo menos :setting:`TEMPLATE_DIRS` (se você estiver 
usando carregadores de template), :setting:`DEFAULT_CHARSET` (embora o padrão 
seja ``utf-8`` seja legal) e :setting:`TEMPLATE_DEBUG`. Toda variável de 
configuração está descrita no :ref:`documentação de configurações 
<ref-settings>`, e qualquer configuração que comece com ``TEMPALTE_`` é de 
interesse óbvio.
